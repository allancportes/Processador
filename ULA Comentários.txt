module ULA (op, data1, data2, result, signal_zero, signal_neg, shamt); //modulo pode ser comparado a um componente de um circuito

	//Declaraçao de entrada e saida
	input [31:0]data1;
	input [31:0]data2; 
	input [4:0]shamt; //shamt possui 5bits
	input [4:0]op; //op possui 4bits

	output signal_zero; //por padrao o programa assume que output wire 
	output signal_neg;
	output reg [31:0]result; //utiliza output reg pois pode salvar um determinado estado logico ate que o mesmo seja modificado, podemos comparar a um flip flop
	
	//assign  //utilizamos o assign pois sera criado um circuito combinacional
	
	
	always @(data1 or data2 or op or shamt) begin
		case(op[4:0])
			5'b00000: result = data1 + data2; //add
		   5'b00001: result = data1 - data2; //sub
		   5'b00010: result = data1 + 1; 	//addi
		   5'b00011: result = data1 - 1;  //subi
		   5'b00100: result = data1 < data2 ? 1 : 0; //slt
		   5'b00101: result = data1[15:0] * data2[15:0]; //mult
		   5'b00110: result = data1 > data2 ? 1 : 0; // Set greater than (Branch)
		   5'b00111: result = data1 << shamt;//shfl
		   5'b01000: result = data1 >> shamt; //shfr
		   5'b01001: result = ~data1; //not
		   5'b01010: result = data1 & data2; //and
		   5'b01011: result = data1 | data2; //or
		   5'b01100: result = data1 ^ data2; //xor
			5'b01101 : result = data1 == data2 ? 1: 0; // Set equal than (Branch)
			5'b01110 : result = data1 <= data2 ? 1 : 0; // Set less or equal than (Branch)
			5'b01111 : result = data1 >= data2 ? 1 : 0; // Set greater or equal than (Branch)
			5'b10000 : result = data1 != data2 ? 1 : 0; // Set different	
			5'b10001 : result = data1 == 0 ? 1 : 0; //Branch and equal zero - beqz 
			default : result = 0;
		endcase
	end
	
	assign signal_zero = (result == 0); //indica quando o resultado - 0, sera utilizado pelas funçoes de branch
	assign signal_neg = (($signed(result) < 0));
	
	
endmodule 